#!/usr/bin/env ruby
# frozen_string_literal: true

require "active_support/all"
require "action_view/helpers/number_helper"
require "benchmark"
require "pry-byebug"
require "rainbow"
require_relative "../test/rails_kit/setup"
require_relative "../lib/universalid"

include ActionView::Helpers::NumberHelper

@iterations = 10
@max_record_count = 100

# seed data ..................................................................................................

def increment(reset: false)
  @number = 0 if reset
  print "\e[A\e[K"
  print Rainbow("Creating ").cyan
  print Rainbow(@number).lime
  puts Rainbow(" records").cyan
  @number += 1
end

@campaign ||= begin
  done = false
  increment(reset: true)
  Campaign.create_for_test do |c|
    emails = Email.create_for_test(@max_record_count / 4, campaign: c) { increment }

    emails.each do |email|
      break if done
      rand(2..8).times do
        done = increment > @max_record_count
        break if done
        Attachment.create_for_test email: email
      end
    end
  end
end

# load associations into memory so they can be included in the pack or UID
@campaign.emails.each { |e| e.attachments.load }

def publish(label)
  puts "\n#{label}"
  yield if block_given?
end

def run(label, iterations: @iterations)
  GC.disable
  Benchmark.benchmark(Benchmark::CAPTION, 52, Benchmark::FORMAT, "Avg Milliseconds per/iteration", "Avg Milliseconds per/record") do |x|
    time = x.report(Rainbow("#{label} ".ljust(53, ".")).cyan) { iterations.times { yield } }
    avg_seconds_per_iteration = time / iterations
    avg_seconds_per_record = avg_seconds_per_iteration / @max_record_count
    [avg_seconds_per_iteration * 1_000, avg_seconds_per_record * 1_000]
  end
ensure
  GC.enable
end

# benchmarks .................................................................................................
publish(
  [
    Rainbow("Benchmarking ").cyan.bright,
    Rainbow(number_with_delimiter(@iterations)).lime,
    Rainbow(" #{"iteration".pluralize(@iterations)} ").cyan.bright,
    Rainbow("with ").cyan.bright,
    Rainbow(number_with_delimiter(Campaign.count + Email.count + Attachment.count)).lime,
    Rainbow(" related records marshaled as an atomic singular unit").cyan.bright
  ].join
)

# ............................................................................................................
#run("UID.build Hash ....... +descendants") { URI::UID.build campaign_hash }
#run("UID.build ActiveRecord +descendants") { URI::UID.build campaign, include_descendants: true, descendant_depth: 2 }
#run("UID.build ActiveRecord +descendants copy") { URI::UID.build campaign, include_keys: false, include_descendants: true, descendant_depth: 2 }
## ............................................................................................................
#run("UID.build Hash ....... +descendants -blank") { URI::UID.build campaign_hash, include_blank: false }
#run("UID.build ActiveRecord +descendants -blank") { URI::UID.build campaign, include_blank: false, include_descendants: true, descendant_depth: 2 }
#run("UID.build ActiveRecord +descendants -blank copy") { URI::UID.build campaign, include_keys: false, include_blanks: false, include_descendants: true, descendant_depth: 2 }
## ............................................................................................................
#run("UID.parse Hash ....... +descendants") { URI::UID.parse campaign_hash_uid_string }
#run("UID.parse ActiveRecord +descendants") { URI::UID.parse campaign_uid_string }
## ............................................................................................................
#run("UID.decode Hash ....... +descendants") { campaign_hash_uid.decode }
#run("UID.decode ActiveRecord +descendants") { campaign_uid.decode }
## ............................................................................................................
#run("ActiveRecord → GlobalID") { campaign.to_gid_param }
#run("ActiveRecord → SignedGlobalID") { campaign.to_sgid_param }
#run("Encoder.encode ActiveRecord -descentants (== gid)") { UniversalID::Encoder.encode campaign }
#run("UID.build ActiveRecord -descentants") { URI::UID.build campaign }
#run("UID.build ActiveRecord -descentants -blank") { URI::UID.build campaign, include_blank: false }
#run("UID.build ActiveRecord -descentants -blank copy") { URI::UID.build campaign, include_blank: false, include_keys: false }
## ............................................................................................................
#run("UID → GID → UID.from_gid → UID.decode  +descendants") do
  #URI::UID.from_gid(URI::UID.build(campaign, include_descendants: true, descendant_depth: 2).to_gid_param).decode
#end

#run("UID → SGID → UID.from_sgid → UID.decode +descendants") do
  #URI::UID
    #.from_sgid(URI::UID.build(campaign, include_descendants: true, descendant_depth: 2)
    #.to_sgid_param(for: "benchmarks"), for: "benchmarks").decode
#end

publish Rainbow("ActiveRecord +pks ".ljust(98, ".")).lime.bright do
  packed = UniversalID::Packer.pack(@campaign)
  run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign }
  run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
end

publish Rainbow("ActiveRecord +pks, +descendants ".ljust(98, ".")).lime.bright do
  options = {include_descendants: true, descendant_depth: 2}
  packed = UniversalID::Packer.pack(@campaign, options)
  run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
end

publish Rainbow("ActiveRecord -pks, -fks, -timestamps ".ljust(98, ".")).lime.bright do
  options = {include_keys: false, include_timestamps: false}
  packed = UniversalID::Packer.pack(@campaign, options)
  run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
end

publish Rainbow("ActiveRecord -pks, -fks, -timestamps, +descendants ".ljust(98, ".")).lime.bright do
  options = {include_keys: false, include_timestamps: false, include_descendants: true, descendant_depth: 2}
  packed = UniversalID::Packer.pack(@campaign, options)
  run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
end

publish Rainbow("Native Ruby ".ljust(98, ".")).red.bright do
  dumped = Marshal.dump @campaign
  run("Marshal.dump") { Marshal.dump @campaign }
  run("Marshal.load") { Marshal.load dumped }
end
