#!/usr/bin/env ruby
# frozen_string_literal: true

require "active_support/all"
require "action_view/helpers/number_helper"
require "awesome_print"
require "benchmark"
require "pry-byebug"
require "rainbow"
require_relative "lib/runner"
require_relative "../test/rails_kit/setup"
require_relative "../lib/universalid"

include ActionView::Helpers::NumberHelper
include Writer
include Runner

ITERATIONS = 10
MAX_RECORD_COUNT = 100

# seed data ..................................................................................................
@campaign ||= begin
  done = false

  increment = -> do
    @count ||= 0
    rewrite "#{style("Creating", :cyan)} #{style(@count, :lime)} #{style("records", :cyan)}"
    @count += 1
  end

  increment.call
  Campaign.create_for_test do |c|
    emails = Email.create_for_test(MAX_RECORD_COUNT / 4, campaign: c) { increment.call }

    emails.each do |email|
      break if done
      rand(2..8).times do
        done = increment.call > MAX_RECORD_COUNT
        break if done
        Attachment.create_for_test email: email
      end
    end
  end
end

# load associations into memory so they can be included in the pack or UID
@campaign.emails.each { |e| e.attachments.load }

# benchmarks .................................................................................................
write(
  [
    style("Benchmarking ", :cyan, :bright),
    style(number_with_delimiter(ITERATIONS), :lime),
    style(" #{"iteration".pluralize(ITERATIONS)} ", :cyan, :bright),
    style("with ", :cyan, :bright),
    style(number_with_delimiter(Campaign.count + Email.count + Attachment.count), :lime),
    style(" related records marshaled as an atomic singular unit", :cyan, :bright)
  ].join
)

# ............................................................................................................
#run("UID.build Hash ....... +descendants") { URI::UID.build campaign_hash }
#run("UID.build ActiveRecord +descendants") { URI::UID.build campaign, include_descendants: true, descendant_depth: 2 }
#run("UID.build ActiveRecord +descendants copy") { URI::UID.build campaign, include_keys: false, include_descendants: true, descendant_depth: 2 }
## ............................................................................................................
#run("UID.build Hash ....... +descendants -blank") { URI::UID.build campaign_hash, include_blank: false }
#run("UID.build ActiveRecord +descendants -blank") { URI::UID.build campaign, include_blank: false, include_descendants: true, descendant_depth: 2 }
#run("UID.build ActiveRecord +descendants -blank copy") { URI::UID.build campaign, include_keys: false, include_blanks: false, include_descendants: true, descendant_depth: 2 }
## ............................................................................................................
#run("UID.parse Hash ....... +descendants") { URI::UID.parse campaign_hash_uid_string }
#run("UID.parse ActiveRecord +descendants") { URI::UID.parse campaign_uid_string }
## ............................................................................................................
#run("UID.decode Hash ....... +descendants") { campaign_hash_uid.decode }
#run("UID.decode ActiveRecord +descendants") { campaign_uid.decode }
## ............................................................................................................
#run("ActiveRecord → GlobalID") { campaign.to_gid_param }
#run("ActiveRecord → SignedGlobalID") { campaign.to_sgid_param }
#run("Encoder.encode ActiveRecord -descentants (== gid)") { UniversalID::Encoder.encode campaign }
#run("UID.build ActiveRecord -descentants") { URI::UID.build campaign }
#run("UID.build ActiveRecord -descentants -blank") { URI::UID.build campaign, include_blank: false }
#run("UID.build ActiveRecord -descentants -blank copy") { URI::UID.build campaign, include_blank: false, include_keys: false }
## ............................................................................................................
#run("UID → GID → UID.from_gid → UID.decode  +descendants") do
  #URI::UID.from_gid(URI::UID.build(campaign, include_descendants: true, descendant_depth: 2).to_gid_param).decode
#end

#run("UID → SGID → UID.from_sgid → UID.decode +descendants") do
  #URI::UID
    #.from_sgid(URI::UID.build(campaign, include_descendants: true, descendant_depth: 2)
    #.to_sgid_param(for: "benchmarks"), for: "benchmarks").decode
#end

# ............................................................................................................

dumped = Marshal.dump(@campaign)
loaded = Marshal.load(dumped)
write "Marshal", :yellow, :bright, pad: "⎯", subtext: <<~DESC
  Creates a deep COPY of the record and it's associations using Ruby's native Marshal.
  This serves as the baseline for comparison with UniversalID serialization.
DESC
baseline = {
  dump: run("Marshal.dump") { Marshal.dump @campaign },
  load: run("Marshal.load") { Marshal.load dumped }
}
puts
puts "#{style "Payload size", :faint, width: Runner::WIDTH, pad: "."}  #{number_to_human_size dumped.bytesize} #{style "(baseline)", :faint}"

# ............................................................................................................

packed = UniversalID::Packer.pack(@campaign)
write "UniversalID::Packer", :cyan, :bright, pad: "⎯", subtext: <<~DESC
  Creates a shallow COPY of the record without associations.
  Only serializes the primary key and does not include unsaved changes.
  Unpack performs a database query to retrieve the record and hydrates an ActiveRecord model.
  NOTE: This acts like a deep copy because the associations can be lazy loaded from the database.
DESC
results = {
  pack: run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign },
  unpack: run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
}
compare packed.bytesize, dumped.bytesize,
  formatted: number_to_human_size(packed.bytesize, precision: 2), label: "Payload size", baseline_label: "Marshal.dump", header: true
compare results[:pack][:avg_ms_per_record].real, baseline[:dump][:avg_ms_per_record].real,
  formatted: number_to_human(results[:pack][:avg_ms_per_record].real, precision: 2) + "ms", label: "Pack avg ms/record", baseline_label: "Marshal.dump"
compare results[:unpack][:avg_ms_per_record].real, baseline[:load][:avg_ms_per_record].real,
  formatted: number_to_human(results[:unpack][:avg_ms_per_record].real, precision: 2) + "ms", label: "Unpack avg ms/record", baseline_label: "Marshal.load"

#publish Rainbow("ActiveRecord +pks, +descendants ".ljust(98, ".")).lime.bright do
  #options = {include_descendants: true, descendant_depth: 2}
  #packed = UniversalID::Packer.pack(@campaign, options)
  #run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  #run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
#end

#publish Rainbow("ActiveRecord -pks, -fks, -timestamps ".ljust(98, ".")).lime.bright do
  #options = {include_keys: false, include_timestamps: false}
  #packed = UniversalID::Packer.pack(@campaign, options)
  #run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  #run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
#end

#publish Rainbow("ActiveRecord -pks, -fks, -timestamps, +descendants ".ljust(98, ".")).lime.bright do
  #options = {include_keys: false, include_timestamps: false, include_descendants: true, descendant_depth: 2}
  #packed = UniversalID::Packer.pack(@campaign, options)
  #run("UniversalID::Packer.pack") { UniversalID::Packer.pack @campaign, options }
  #run("UniversalID::Packer.unpack") { UniversalID::Packer.unpack packed }
#end
